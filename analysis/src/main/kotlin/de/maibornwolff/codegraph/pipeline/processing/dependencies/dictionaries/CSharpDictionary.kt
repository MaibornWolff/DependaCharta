package de.maibornwolff.codegraph.pipeline.processing.dependencies.dictionaries

import de.maibornwolff.codegraph.pipeline.analysis.model.Path

class CSharpDictionary : LanguageDictionary {
    override fun get(): Map<String, Path> = cSharpDictionary

    companion object {
        val cSharpKeywords = mapOf(
            "abstract" to "abstract",
            "as" to "as",
            "base" to "base",
            "bool" to "bool",
            "break" to "break",
            "byte" to "byte",
            "case" to "case",
            "catch" to "catch",
            "char" to "char",
            "checked" to "checked",
            "class" to "class",
            "const" to "const",
            "continue" to "continue",
            "decimal" to "decimal",
            "default" to "default",
            "delegate" to "delegate",
            "do" to "do",
            "double" to "double",
            "else" to "else",
            "enum" to "enum",
            "event" to "event",
            "explicit" to "explicit",
            "extern" to "extern",
            "false" to "false",
            "finally" to "finally",
            "fixed" to "fixed",
            "float" to "float",
            "for" to "for",
            "foreach" to "foreach",
            "goto" to "goto",
            "if" to "if",
            "implicit" to "implicit",
            "in" to "in",
            "int" to "int",
            "interface" to "interface",
            "internal" to "internal",
            "is" to "is",
            "lock" to "lock",
            "long" to "long",
            "namespace" to "namespace",
            "new" to "new",
            "null" to "null",
            "object" to "object",
            "operator" to "operator",
            "out" to "out",
            "override" to "override",
            "params" to "params",
            "private" to "private",
            "protected" to "protected",
            "public" to "public",
            "readonly" to "readonly",
            "ref" to "ref",
            "return" to "return",
            "sbyte" to "sbyte",
            "sealed" to "sealed",
            "short" to "short",
            "sizeof" to "sizeof",
            "stackalloc" to "stackalloc",
            "static" to "static",
            "string" to "string",
            "struct" to "struct",
            "switch" to "switch",
            "this" to "this",
            "throw" to "throw",
            "true" to "true",
            "try" to "try",
            "type" to "type",
            "typeof" to "typeof",
            "uint" to "uint",
            "ulong" to "ulong",
            "unchecked" to "unchecked",
            "unsafe" to "unsafe",
            "ushort" to "ushort",
            "using" to "using",
            "virtual" to "virtual",
            "void" to "void",
            "volatile" to "volatile",
            "while" to "while",
        )
    }

    private val cSharpDictionary = cSharpKeywords.mapValues { Path(it.value.split(".")) }
}
